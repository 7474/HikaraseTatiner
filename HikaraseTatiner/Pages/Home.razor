@page "/"
@using OpenCvSharp;
@using SixLabors.ImageSharp;
@using System.Diagnostics
@inject IJSRuntime jsRuntime;
@inject HttpClient httpClient;
@implements IDisposable;

<PageTitle>HikaraseTatiner</PageTitle>

<h1>HikaraseTatiner</h1>
<div>
    <canvas @ref="srcCanvas" width="@canvasWidth" height="@canvasHeight" style="max-width: 100%; border:1px solid gray; display: none;">
        Your browser does not support the HTML5 canvas tag.
    </canvas>
    <canvas @ref="dstCanvas" width="@canvasWidth" height="@canvasHeight" style="max-width: 100%; border:1px solid gray;">
        Your browser does not support the HTML5 canvas tag.
    </canvas>
</div>
<div style="display: none;">
    <button @onclick="@(async () => await Grayscale())" class="btn btn-primary">Grayscale</button>
    <button @onclick="@(async () => await PseudoColor())" class="btn btn-primary">PseudoColor</button>
    <button @onclick="@(async () => await Threshold())" class="btn btn-secondary">Threshold</button>
    <button @onclick="@(async () => await Canny())" class="btn btn-secondary">Canny</button>
    <button @onclick="@(async () => await Akaze())" class="btn btn-secondary">AKAZE</button>
</div>
<div>
    <InputFile OnChange="OnInputFileChange" class="form-control" />
</div>
<div>
    <input type="color" @bind="hikaraseColor" />
    <button @onclick="@(async () => await Hikarase())" class="btn btn-primary">Hikarase</button>
    <button @onclick="@(async () => await Niji())" class="btn btn-warning">Niji</button>
    <button @onclick="@(async () => await Save())" class="btn btn-success">Save</button>
</div>
<div>
    <pre><code>@log</code></pre>
</div>

@code {
    private int canvasWidth = 512;
    private int canvasHeight = 512;
    private string log = "";

    private Mat? srcMat;
    private Mat? dstMat;
    private ElementReference srcCanvas;
    private ElementReference dstCanvas;
    private CanvasClient? srcCanvasClient;
    private CanvasClient? dstCanvasClient;

    private Mat? outlineMat;
    private string hikaraseColor;

    public void Dispose()
    {
        srcMat?.Dispose();
        dstMat?.Dispose();

        outlineMat?.Dispose();
    }

    protected override async Task OnInitializedAsync()
    {
        System.Console.WriteLine($"OnInitializedAsync");
        await base.OnInitializedAsync();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        System.Console.WriteLine($"OnAfterRenderAsync");
        await base.OnAfterRenderAsync(firstRender);

        srcCanvasClient ??= new CanvasClient(jsRuntime, srcCanvas);
        dstCanvasClient ??= new CanvasClient(jsRuntime, dstCanvas);
    }

    private async Task OnInputFileChange(InputFileChangeEventArgs e)
    {
        log = "Loading...";
        StateHasChanged();
        await Task.Delay(1);

        var sw = new Stopwatch();
        sw.Start();

        var file = e.File;
        using var ins = file.OpenReadStream(1024 * 1024 * 10);
        using var image = await Image.LoadAsync(ins);
        System.Console.WriteLine($"image: {image.Width} x {image.Height}");
        var lapLoad = sw.ElapsedMilliseconds;

        using var ms = new MemoryStream();
        await image.SaveAsBmpAsync(ms);
        System.Console.WriteLine($"ms: {ms.Length}");
        var lapBuildBmp = sw.ElapsedMilliseconds;

        var mat = Cv2.ImDecode(ms.ToArray(), ImreadModes.Unchanged);
        System.Console.WriteLine($"mat: {mat.Width} x {mat.Height}");
        var lapCopyToMat = sw.ElapsedMilliseconds;

        srcMat?.Dispose();
        srcMat = mat;

        if (srcCanvasClient == null) { return; }
        await DrawMatAsync(srcMat, srcCanvasClient);
        await DrawMatAsync(srcMat, dstCanvasClient);
        var lapDrawCanvas = sw.ElapsedMilliseconds;


        using var tmpMat = new Mat();
        using var grayMat = new Mat();
        Cv2.Resize(mat, tmpMat, new OpenCvSharp.Size(), (double)canvasWidth / mat.Width, (double)canvasHeight / mat.Height);
        Cv2.CvtColor(tmpMat, grayMat, ColorConversionCodes.BGR2GRAY);
        Cv2.Canny(grayMat, tmpMat, 32, 128, 3, false);

        outlineMat?.Dispose();
        outlineMat = tmpMat.Clone();
        // await DrawMatAsync(outlineMat, dstCanvasClient);

        sw.Stop();
        log = $@"Size: {mat.Width} x {mat.Height}
    Total: {sw.ElapsedMilliseconds}
    - Load: {lapLoad}
    - BuildBmp: {lapBuildBmp - lapLoad}
    - CopyToMat: {lapCopyToMat - lapBuildBmp}
    - DrawCanvas: {lapDrawCanvas - lapCopyToMat}
    ";
    }

    private async Task Save()
    {
        if (dstMat is null)
            throw new InvalidOperationException($"{nameof(dstMat)} is null");

        log = "Saving...";
        StateHasChanged();
        await Task.Delay(1);

        var sw = new Stopwatch();
        sw.Start();

        System.Console.WriteLine($"mat: {dstMat.Width} x {dstMat.Height}");
        using var tmpMs = dstMat.ToMemoryStream(".bmp");
        using var image = await Image.LoadAsync(tmpMs);
        System.Console.WriteLine($"image: {image.Width} x {image.Height}");
        var lapLoadBmp = sw.ElapsedMilliseconds;

        using var ms = new MemoryStream();
        await image.SaveAsPngAsync(ms);
        System.Console.WriteLine($"ms: {ms.Length}");
        var lapEncodePng = sw.ElapsedMilliseconds;

        await jsRuntime.InvokeVoidAsync("downloadFile", $"hikarase-tainer-{DateTime.UtcNow.Ticks}.png", "image/png", ms.ToArray());
        var lapInvokeJs = sw.ElapsedMilliseconds;

        sw.Stop();
        log = $@"Size: {image.Width} x {image.Height}
    Total: {sw.ElapsedMilliseconds}
    - LoadBmp: {lapLoadBmp}
    - EncodePng: {lapEncodePng - lapLoadBmp}
    - InvokeJs: {lapInvokeJs - lapLoadBmp}
    ";
    }

    private async Task Hikarase()
    {
        var hColor = ColorCodeToBGR(hikaraseColor);
        System.Console.WriteLine(hColor);

        await ApplyHikarase(hColor);
    }

    private static System.Timers.Timer? nijiTimer;
    private double hue = 0d;

    private async Task Niji()
    {
        if (nijiTimer == null)
        {
            nijiTimer = new System.Timers.Timer(100);
            nijiTimer.Elapsed += NextNiji;
            nijiTimer.Start();
        }
        else
        {
            nijiTimer.Stop();
            nijiTimer.Dispose();
            nijiTimer = null;
        }
    }

    private void NextNiji(object? source, System.Timers.ElapsedEventArgs e)
    {
        hue = (hue + 16) % 256;
        var hColor = HSVToBGR(hue);
        System.Console.WriteLine(hColor);

        ApplyHikarase(hColor).Wait();
    }

    public OpenCvSharp.Scalar HSVToBGR(double hue, double saturation = 1d, double value = 1d)
    {
        int hi = Convert.ToInt32(Math.Floor(hue / 60)) % 6;
        double f = hue / 60 - Math.Floor(hue / 60);

        value = value * 255;
        int v = Convert.ToInt32(value);
        int p = Convert.ToInt32(value * (1 - saturation));
        int q = Convert.ToInt32(value * (1 - f * saturation));
        int t = Convert.ToInt32(value * (1 - (1 - f) * saturation));

        if (hi == 0)
            return new OpenCvSharp.Scalar(p / 255d, t / 255d, v / 255d);
        else if (hi == 1)
            return new OpenCvSharp.Scalar(p / 255d, v / 255d, q / 255d);
        else if (hi == 2)
            return new OpenCvSharp.Scalar(t / 255d, v / 255d, p / 255d);
        else if (hi == 3)
            return new OpenCvSharp.Scalar(v / 255d, q / 255d, p / 255d);
        else if (hi == 4)
            return new OpenCvSharp.Scalar(v / 255d, p / 255d, t / 255d);
        else
            return new OpenCvSharp.Scalar(q / 255d, p / 255d, v / 255d);
    }

    private async Task ApplyHikarase(OpenCvSharp.Scalar hColor)
    {
        if (srcMat is null)
            throw new InvalidOperationException($"{nameof(srcMat)} is null");
        if (outlineMat is null)
            throw new InvalidOperationException($"{nameof(outlineMat)} is null");
        if (dstCanvasClient is null)
            throw new InvalidOperationException($"{nameof(dstCanvasClient)} is null");

        var sw = new Stopwatch();
        sw.Start();

        using var tmpMat = new Mat();
        using var tmpMat2 = new Mat();
        using var tmpMat3 = new Mat();
        Cv2.Resize(outlineMat, tmpMat, new OpenCvSharp.Size(), (double)srcMat.Width / outlineMat.Width, (double)srcMat.Height / outlineMat.Height);
        System.Console.WriteLine($"Resize: {sw.Elapsed}");
        Cv2.CvtColor(tmpMat, tmpMat2, ColorConversionCodes.GRAY2BGR);
        System.Console.WriteLine($"CvtColor: {sw.Elapsed}");
        Cv2.Multiply(tmpMat2, hColor, tmpMat3);
        Cv2.Blur(tmpMat3, tmpMat2, new OpenCvSharp.Size(tmpMat2.Width / 256, tmpMat2.Height / 256));
        Cv2.Blur(tmpMat2, tmpMat3, new OpenCvSharp.Size(tmpMat2.Width / 64, tmpMat2.Height / 64));

        using var hikaraseMat = new Mat();
        Cv2.AddWeighted(srcMat, 1d, tmpMat3, 0.5d, 0d, hikaraseMat);
        Cv2.AddWeighted(hikaraseMat, 1d, tmpMat2, 0.75d, 0d, hikaraseMat);
        System.Console.WriteLine($"AddWeighted: {sw.Elapsed}");

        await DrawMatAsync(hikaraseMat, dstCanvasClient);
        await DrawMatAsync(tmpMat2, srcCanvasClient);
    }

    private OpenCvSharp.Scalar ColorCodeToBGR(string htmlColor)
    {
        if (htmlColor.StartsWith("#"))
        {
            htmlColor = htmlColor.Substring(1);
        }

        if (htmlColor.Length == 3)
        {
            htmlColor = $"{htmlColor[0]}{htmlColor[0]}{htmlColor[1]}{htmlColor[1]}{htmlColor[2]}{htmlColor[2]}";
        }

        int r = int.Parse(htmlColor.Substring(0, 2), System.Globalization.NumberStyles.HexNumber);
        int g = int.Parse(htmlColor.Substring(2, 2), System.Globalization.NumberStyles.HexNumber);
        int b = int.Parse(htmlColor.Substring(4, 2), System.Globalization.NumberStyles.HexNumber);

        return new OpenCvSharp.Scalar(b / 255d, g / 255d, r / 255d);
    }

    private async Task DrawMatAsync(Mat mat, CanvasClient target)
    {
        System.Console.WriteLine($"DrawMatAsync: {target.GetHashCode()}");
        dstMat?.Dispose();
        dstMat = mat.Clone();
        if (mat.Width != canvasWidth || mat.Height != canvasHeight)
        {
            using var tmpMat = new Mat();
            Cv2.Resize(mat, tmpMat, new OpenCvSharp.Size(), (double)canvasWidth / mat.Width, (double)canvasHeight / mat.Height);
            await target.DrawMatAsync(tmpMat);
        }
        else
        {
            await target.DrawMatAsync(mat);
        }
    }

    private async Task Grayscale()
    {
        if (srcMat is null)
            throw new InvalidOperationException($"{nameof(srcMat)} is null");
        if (dstCanvasClient is null)
            throw new InvalidOperationException($"{nameof(dstCanvasClient)} is null");

        using var grayMat = new Mat();
        Cv2.CvtColor(srcMat, grayMat, ColorConversionCodes.BGR2GRAY);

        await DrawMatAsync(grayMat, dstCanvasClient);
    }

    private async Task PseudoColor()
    {
        if (srcMat is null)
            throw new InvalidOperationException($"{nameof(srcMat)} is null");
        if (dstCanvasClient is null)
            throw new InvalidOperationException($"{nameof(dstCanvasClient)} is null");

        using var grayMat = new Mat();
        using var dstMat = new Mat();
        Cv2.CvtColor(srcMat, grayMat, ColorConversionCodes.BGR2GRAY);
        Cv2.ApplyColorMap(grayMat, dstMat, ColormapTypes.Jet);

        await DrawMatAsync(dstMat, dstCanvasClient);
    }

    private async Task Threshold()
    {
        if (srcMat is null)
            throw new InvalidOperationException($"{nameof(srcMat)} is null");
        if (dstCanvasClient is null)
            throw new InvalidOperationException($"{nameof(dstCanvasClient)} is null");

        using var grayMat = new Mat();
        using var dstMat = new Mat();
        Cv2.CvtColor(srcMat, grayMat, ColorConversionCodes.BGR2GRAY);
        Cv2.Threshold(grayMat, dstMat, 0, 255, ThresholdTypes.Binary | ThresholdTypes.Otsu);

        await DrawMatAsync(dstMat, dstCanvasClient);
    }

    private async Task Canny()
    {
        if (srcMat is null)
            throw new InvalidOperationException($"{nameof(srcMat)} is null");
        if (dstCanvasClient is null)
            throw new InvalidOperationException($"{nameof(dstCanvasClient)} is null");

        using var grayMat = new Mat();
        using var dstMat = new Mat();
        Cv2.CvtColor(srcMat, grayMat, ColorConversionCodes.BGR2GRAY);
        Cv2.Canny(grayMat, dstMat, 32, 128);

        await DrawMatAsync(dstMat, dstCanvasClient);
    }

    private async Task Akaze()
    {
        if (srcMat is null)
            throw new InvalidOperationException($"{nameof(srcMat)} is null");
        if (dstCanvasClient is null)
            throw new InvalidOperationException($"{nameof(dstCanvasClient)} is null");

        using var grayMat = new Mat();
        Cv2.CvtColor(srcMat, grayMat, ColorConversionCodes.BGR2GRAY);

        using var akaze = AKAZE.Create();
        using var descriptors = new Mat();
        akaze.DetectAndCompute(grayMat, null, out var keypoints, descriptors);

        using var dstMat = srcMat.Clone();
        Cv2.DrawKeypoints(srcMat, keypoints, dstMat);

        await DrawMatAsync(dstMat, dstCanvasClient);
    }
}
