@page "/"
@using OpenCvSharp;
@using SixLabors.ImageSharp;
@using System.Diagnostics
@inject IJSRuntime jsRuntime;
@inject HttpClient httpClient;
@implements IDisposable;

<PageTitle>HikaraseTatiner Sample</PageTitle>

<h1>HikaraseTatiner</h1>

<div>
    <canvas @ref="srcCanvas" width="@canvasWidth" height="@canvasHeight" style="border:1px solid gray;">
        Your browser does not support the HTML5 canvas tag.
    </canvas>
    <canvas @ref="dstCanvas" width="@canvasWidth" height="@canvasHeight" style="border:1px solid gray;">
        Your browser does not support the HTML5 canvas tag.
    </canvas>
</div>
<div>
    <button @onclick="@(async () => await Grayscale())">Grayscale</button>
    <button @onclick="@(async () => await PseudoColor())">PseudoColor</button>
    <button @onclick="@(async () => await Threshold())" style="color: darkgray;">Threshold</button>
    <button @onclick="@(async () => await Canny())" style="color: darkgray;">Canny</button>
    <button @onclick="@(async () => await Akaze())" style="color: darkgray;">AKAZE</button>
</div>
<div>
    <InputFile OnChange="OnInputFileChange" multiple />
    <button @onclick="@(async () => await Save())">Save</button>
</div>
<div>
    <pre>@log</pre>
</div>

@code {
    private int canvasWidth = 512;
    private int canvasHeight = 512;
    private string log = "";

    private Mat? srcMat;
    private Mat? dstMat;
    private ElementReference srcCanvas;
    private ElementReference dstCanvas;
    private CanvasClient? srcCanvasClient;
    private CanvasClient? dstCanvasClient;

    public void Dispose()
    {
        srcMat?.Dispose();
        dstMat?.Dispose();
    }

    protected override async Task OnInitializedAsync()
    {
        System.Console.WriteLine($"OnInitializedAsync");
        await base.OnInitializedAsync();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        System.Console.WriteLine($"OnAfterRenderAsync");
        await base.OnAfterRenderAsync(firstRender);

        srcCanvasClient ??= new CanvasClient(jsRuntime, srcCanvas);
        dstCanvasClient ??= new CanvasClient(jsRuntime, dstCanvas);
    }

    private async Task OnInputFileChange(InputFileChangeEventArgs e)
    {
        var sw = new Stopwatch();
        sw.Start();

        var file = e.File;
        using var ins = file.OpenReadStream(1024 * 1024 * 10);
        using var image = await Image.LoadAsync(ins);
        System.Console.WriteLine($"image: {image.Width} x {image.Height}");
        var lapLoad = sw.ElapsedMilliseconds;

        using var ms = new MemoryStream();
        await image.SaveAsBmpAsync(ms);
        System.Console.WriteLine($"ms: {ms.Length}");
        var lapBuildBmp = sw.ElapsedMilliseconds;

        var mat = Cv2.ImDecode(ms.ToArray(), ImreadModes.Unchanged);
        System.Console.WriteLine($"mat: {mat.Width} x {mat.Height}");
        var lapCopyToMat = sw.ElapsedMilliseconds;

        srcMat?.Dispose();
        srcMat = mat;

        if (srcCanvasClient == null) { return; }
        await DrawMatAsync(srcMat, srcCanvasClient);
        var lapDrawCanvas = sw.ElapsedMilliseconds;

        sw.Stop();
        log = $@"Total: {sw.ElapsedMilliseconds}
- Load: {lapLoad}
- BuildBmp: {lapBuildBmp - lapLoad}
- CopyToMat: {lapCopyToMat - lapBuildBmp}
- DrawCanvas: {lapDrawCanvas - lapCopyToMat}
";
    }

    private async Task Save()
    {
        if (dstMat is null)
            throw new InvalidOperationException($"{nameof(dstMat)} is null");

        var sw = new Stopwatch();
        sw.Start();

        System.Console.WriteLine($"mat: {dstMat.Width} x {dstMat.Height}");
        using var tmpMs = dstMat.ToMemoryStream(".bmp");
        using var image = Image.Load(tmpMs);
        System.Console.WriteLine($"image: {image.Width} x {image.Height}");
        var lapLoadBmp = sw.ElapsedMilliseconds;

        using var ms = new MemoryStream();
        await image.SaveAsPngAsync(ms);
        System.Console.WriteLine($"ms: {ms.Length}");
        var lapEncodePng = sw.ElapsedMilliseconds;

        await jsRuntime.InvokeVoidAsync("downloadFile", $"hikarase-tainer-{DateTime.UtcNow.Ticks}.png", "image/png", ms.ToArray());
        var lapInvokeJs = sw.ElapsedMilliseconds;

        sw.Stop();
        log = $@"total: {sw.ElapsedMilliseconds}
- LoadBmp: {lapLoadBmp}
- EncodePng: {lapEncodePng - lapLoadBmp}
- InvokeJs: {lapInvokeJs - lapLoadBmp}
";
    }

    private async Task DrawMatAsync(Mat mat, CanvasClient target)
    {
        System.Console.WriteLine($"DrawMatAsync: {target.GetHashCode()}");
        dstMat?.Dispose();
        dstMat = mat.Clone();
        if (mat.Width != canvasWidth || mat.Height != canvasHeight)
        {
            using var tmpMat = new Mat();
            Cv2.Resize(mat, tmpMat, new OpenCvSharp.Size(), (double)canvasWidth / mat.Width, (double)canvasHeight / mat.Height);
            await target.DrawMatAsync(tmpMat);
        }
        else
        {
            await target.DrawMatAsync(mat);
        }
    }

    private async Task Grayscale()
    {
        if (srcMat is null)
            throw new InvalidOperationException($"{nameof(srcMat)} is null");
        if (dstCanvasClient is null)
            throw new InvalidOperationException($"{nameof(dstCanvasClient)} is null");

        using var grayMat = new Mat();
        Cv2.CvtColor(srcMat, grayMat, ColorConversionCodes.BGR2GRAY);

        await DrawMatAsync(grayMat, dstCanvasClient);
    }

    private async Task PseudoColor()
    {
        if (srcMat is null)
            throw new InvalidOperationException($"{nameof(srcMat)} is null");
        if (dstCanvasClient is null)
            throw new InvalidOperationException($"{nameof(dstCanvasClient)} is null");

        using var grayMat = new Mat();
        using var dstMat = new Mat();
        Cv2.CvtColor(srcMat, grayMat, ColorConversionCodes.BGR2GRAY);
        Cv2.ApplyColorMap(grayMat, dstMat, ColormapTypes.Jet);

        await DrawMatAsync(dstMat, dstCanvasClient);
    }

    private async Task Threshold()
    {
        if (srcMat is null)
            throw new InvalidOperationException($"{nameof(srcMat)} is null");
        if (dstCanvasClient is null)
            throw new InvalidOperationException($"{nameof(dstCanvasClient)} is null");

        using var grayMat = new Mat();
        using var dstMat = new Mat();
        Cv2.CvtColor(srcMat, grayMat, ColorConversionCodes.BGR2GRAY);
        Cv2.Threshold(grayMat, dstMat, 0, 255, ThresholdTypes.Binary | ThresholdTypes.Otsu);

        await DrawMatAsync(dstMat, dstCanvasClient);
    }

    private async Task Canny()
    {
        if (srcMat is null)
            throw new InvalidOperationException($"{nameof(srcMat)} is null");
        if (dstCanvasClient is null)
            throw new InvalidOperationException($"{nameof(dstCanvasClient)} is null");

        using var grayMat = new Mat();
        using var dstMat = new Mat();
        Cv2.CvtColor(srcMat, grayMat, ColorConversionCodes.BGR2GRAY);
        Cv2.Canny(grayMat, dstMat, 32, 128);

        await DrawMatAsync(dstMat, dstCanvasClient);
    }

    private async Task Akaze()
    {
        if (srcMat is null)
            throw new InvalidOperationException($"{nameof(srcMat)} is null");
        if (dstCanvasClient is null)
            throw new InvalidOperationException($"{nameof(dstCanvasClient)} is null");

        using var grayMat = new Mat();
        Cv2.CvtColor(srcMat, grayMat, ColorConversionCodes.BGR2GRAY);

        using var akaze = AKAZE.Create();
        using var descriptors = new Mat();
        akaze.DetectAndCompute(grayMat, null, out var keypoints, descriptors);

        using var dstMat = srcMat.Clone();
        Cv2.DrawKeypoints(srcMat, keypoints, dstMat);

        await DrawMatAsync(dstMat, dstCanvasClient);
    }
}